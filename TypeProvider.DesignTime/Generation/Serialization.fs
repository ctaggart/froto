/// Contains an implementation of serialization method for types generated from ProtoBuf messages
[<RequireQualifiedAccess>]
module internal Froto.TypeProvider.Generation.Serialization

open Microsoft.FSharp.Quotations

open Froto.TypeProvider.Core

open Froto.Parser.ClassModel

let private primitiveWriter = function
    | "double" -> <@@ Codec.writeDouble @@>
    | "float" -> <@@ Codec.writeFloat @@>
    | "int32" -> <@@ Codec.writeInt32 @@>
    | "int64" -> <@@ Codec.writeInt64 @@>
    | "uint32" -> <@@ Codec.writeUInt32 @@>
    | "uint64" -> <@@ Codec.writeUInt64 @@>
    | "sint32" -> <@@ Codec.writeSInt32 @@>
    | "sint64" -> <@@ Codec.writeSInt64 @@>
    | "fixed32" -> <@@ Codec.writeFixed32 @@>
    | "fixed64" -> <@@ Codec.writeFixed64 @@>
    | "sfixed32" -> <@@ Codec.writeSFixed32 @@>
    | "sfixed64" -> <@@ Codec.writeSFixed64 @@>
    | "bool" -> <@@ Codec.writeBool @@>
    | "string" -> <@@ Codec.writeString @@>
    | "bytes" -> <@@ Codec.writeBytes @@>
    | x -> raise <| TypeNotSupportedException x

let private serializeMapExpr buffer this (map: MapDescriptor) =
    let keyWriter = primitiveWriter map.KeyType.ProtobufType
    let keyType = map.ProvidedProperty.PropertyType.GenericTypeArguments.[0]
    let valueType = map.ProvidedProperty.PropertyType.GenericTypeArguments.[1]
    let positionExpr = Expr.Value(map.Position)
    let mapExpr = Expr.PropertyGet(this, map.ProvidedProperty)
    
    match map.ValueType.Kind with
    | Primitive ->
        Expr.callStaticGeneric 
            [keyType; valueType]
            [keyWriter; primitiveWriter map.ValueType.ProtobufType; positionExpr; buffer; mapExpr]
            <@@ Codec.writePrimitiveMap x x x x x @@>
    | Class -> 
        Expr.callStaticGeneric
            [keyType; valueType]
            [keyWriter; positionExpr; buffer; Expr.box mapExpr]
            <@@ Codec.writeMessageMap x x x x @@>
    | Enum ->
        Expr.callStaticGeneric
            [keyType]
            [keyWriter; positionExpr; buffer; mapExpr]
            <@@ Codec.writeEnumMap x x x x @@>
    
/// Creates an expression that serializes all given properties to the given instance of ZeroCopyBuffer
let private serializeProperty buffer this (prop: PropertyDescriptor) =

    let value = Expr.PropertyGet(this, prop.ProvidedProperty)
    let position = prop.Position
    
    // writer is an expression that represents a function 'T -> unit for any primitive or enum field of type 'T.
    // For embedded messages, writer will have type Message -> unit. It's caused by the fact that it's not possible to pass
    // any generic arguments including option<'T> and 'T -> unit to other functions if 'T is generated by a type provider.
    let writer =
        match prop.Type.Kind with
            | Primitive -> primitiveWriter prop.Type.ProtobufType
            | Class -> <@@ Codec.writeEmbedded @@>
            | Enum -> <@@ Codec.writeInt32 @@>
    
    let callPrimitive writer rule =
        let args =  [Expr.Value(position); buffer; value]
        match rule with
        | Required -> Expr.apply writer args
        | Optional -> 
            Expr.callStaticGeneric 
                [prop.Type.UnderlyingType]
                (writer::args)
                <@@ Codec.writeOptional x x x x @@> 
        | Repeated -> 
            Expr.callStaticGeneric 
                [prop.Type.UnderlyingType]
                (writer::args)
                <@@ Codec.writeRepeated x x x x @@> 
    try
        match prop.Type.Kind, prop.Rule with
        | Class, Optional -> 
            Expr.callStaticGeneric 
                [prop.Type.UnderlyingType] 
                [Expr.Value(position); buffer; Expr.box value]  
                <@@ Codec.writeOptionalEmbedded x x x @@>
        | Class, Repeated ->
            Expr.callStaticGeneric 
                [prop.Type.UnderlyingType] 
                [Expr.Value(position); buffer; Expr.box value]  
                <@@ Codec.writeRepeatedEmbedded x x x @@>
        | Class, Required ->  
            <@@ Codec.writeEmbedded x x x @@> 
            |> Expr.getMethodDef 
            |> Expr.callStatic [Expr.Value position; buffer; Expr.Coerce(value, typeof<Message>)]
        | Enum, rule -> callPrimitive <@@ Codec.writeInt32 @@> rule
        | Primitive, rule -> callPrimitive (primitiveWriter prop.Type.ProtobufType) rule
    with
    | ex -> 
        printfn "Failed to serialize property %s: %O. Error: %O" prop.ProvidedProperty.Name value.Type ex
        reraise()

let serializeExpr (typeInfo: TypeDescriptor) buffer this = 

    let properties =
        typeInfo.AllProperties
        |> List.sortBy (fun prop -> prop.Position)
        |> List.map (serializeProperty buffer this)
        |> Expr.sequence
        
    let maps =
        typeInfo.Maps
        |> List.sortBy (fun map -> map.Position)
        |> List.map (serializeMapExpr buffer this)
        |> Expr.sequence
        
    Expr.Sequential(properties, maps)